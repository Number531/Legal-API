/**
 * CourtListener Web Search Client (Exa-only)
 * Uses Exa to search CourtListener content without hitting the CourtListener API.
 * This avoids CourtListener rate limits while returning structured links and metadata.
 */

import { validateDate, validateLimit } from '../utils/validation.js';

export class CourtListenerWebSearchClient {
  constructor(rateLimiter) {
    this.rateLimiter = rateLimiter;
    this.exaApiKey = process.env.EXA_API_KEY;

    if (!this.exaApiKey) {
      console.warn('EXA_API_KEY not configured. CourtListener web search will not be available.');
    }
  }

  /**
   * Search CourtListener opinions via Exa (domain-restricted)
   * @param {Object} args
   * @param {string} args.query - free-text query
   * @param {string} [args.case_name] - optional exact case name phrase
   * @param {string} [args.citation] - optional citation to target
   * @param {string} [args.date_after] - YYYY-MM-DD filter (applies post-fetch)
   * @param {string} [args.date_before] - YYYY-MM-DD filter (applies post-fetch)
   * @param {number} [args.limit=5] - max results (1-20)
   * @param {boolean} [args.include_text=true] - include snippet text from Exa
   * @param {boolean} [args.include_full_text=false] - include full text content from Exa
   * @returns {Promise<{content: Array}>}
   */
  async searchOpinionsWeb(args) {
    if (!args || typeof args !== 'object') {
      args = {};
    }

    const {
      query,
      case_name,
      citation,
      date_after,
      date_before,
      limit = 5,
      include_text = true,
      include_full_text = false
    } = args;

    if (!query || typeof query !== 'string' || query.trim().length === 0) {
      throw new Error('Query is required for CourtListener web search.');
    }

    if (date_after) validateDate(date_after, 'date_after');
    if (date_before) validateDate(date_before, 'date_before');
    const validatedLimit = validateLimit(limit, 20);

    // Build targeted web query restricted to CourtListener opinions
    let q = 'site:courtlistener.com/opinion ' + query.trim();
    if (case_name) q += ` "${case_name}"`;
    if (citation) q += ` "${citation}"`;

    // Execute Exa search with full text option
    const results = await this.executeExaSearch(q, validatedLimit, include_text, include_full_text);

    // Filter to opinion pages and apply optional date window
    const filtered = results
      .filter(r => (r.url || '').includes('/opinion/'))
      .filter(r => this.filterByDateWindow(r.publishedDate, date_after, date_before));

    const mapped = filtered.map(r => this.mapOpinionResult(r, include_text, include_full_text));

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          search_type: 'courtlistener_opinions_web',
          query: q,
          original_query: query,
          total_results: mapped.length,
          results: mapped
        }, null, 2)
      }]
    };
  }

  /**
   * Lookup a citation via Exa against CourtListener domain only
   * @param {Object} args
   * @param {string} args.citation - citation string (e.g., '410 U.S. 113')
   * @param {number} [args.limit=5] - max results (1-10)
   * @param {boolean} [args.include_text=true] - include snippet text from Exa
   * @param {boolean} [args.include_full_text=false] - include full text content from Exa
   */
  async lookupCitationWeb(args) {
    if (!args || typeof args !== 'object') {
      args = {};
    }
    const { citation, limit = 5, include_text = true, include_full_text = false } = args;
    if (!citation || typeof citation !== 'string' || citation.trim().length === 0) {
      throw new Error('citation is required for lookupCitationWeb');
    }

    const q = `site:courtlistener.com/opinion "${citation.trim()}"`;
    const results = await this.executeExaSearch(q, validateLimit(limit, 10), include_text, include_full_text);
    const filtered = results.filter(r => (r.url || '').includes('/opinion/'));
    const mapped = filtered.map(r => this.mapOpinionResult(r, include_text, include_full_text));

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          search_type: 'courtlistener_citation_web',
          citation: citation,
          total_results: mapped.length,
          results: mapped
        }, null, 2)
      }]
    };
  }

  /**
   * Get opinion with citing/cited cases via web search (Exa-only)
   * Attempts to parse the opinion page sections "Cited by" and "Cites to"
   * @param {Object} args
   * @param {number} args.opinion_id - CourtListener opinion ID
   * @param {boolean} [args.include_citing_cases=true]
   * @param {boolean} [args.include_cited_cases=true]
   * @param {number} [args.citation_depth=1] - Only depth=1 supported for web parsing
   */
  async getOpinionWithCitationsWeb(args) {
    if (!args || typeof args !== 'object') args = {};
    const {
      opinion_id,
      include_citing_cases = true,
      include_cited_cases = true,
      citation_depth = 1
    } = args;

    if (!Number.isInteger(opinion_id) || opinion_id < 1) {
      throw new Error('Invalid opinion_id. Must be a positive integer.');
    }
    if (citation_depth < 1 || citation_depth > 3) {
      throw new Error('Citation depth must be between 1 and 3.');
    }

    // Fetch the opinion page via Exa
    const q = `site:courtlistener.com/opinion/${opinion_id}/`;
    const results = await this.executeExaSearch(q, 1, true);
    if (!results.length) {
      return { content: [{ type: 'text', text: JSON.stringify({ error: 'Opinion page not found', opinion_id }, null, 2) }] };
    }

    const page = results[0];
    const text = page.text || '';
    const caseName = this.cleanCaseTitle(page.title || '') || null;

    const output = {
      opinion: {
        id: opinion_id,
        case_name: caseName,
        absolute_url: page.url || null
      },
      citations: {}
    };

    // Parse citing cases (Cited by)
    if (include_citing_cases) {
      const citedBySection = this.extractSection(text, /Cited\s*by/i);
      const citedByIds = this.findOpinionIdsInText(citedBySection);
      output.citations.citing_this_opinion = citedByIds.map(id => ({ opinion_id: id, relationship: 'cites' }));
    }

    // Parse cited cases (Cites to / Citations)
    if (include_cited_cases) {
      const citesToSection = this.extractSection(text, /(Cites\s*to|Citations?)/i);
      const citedIds = this.findOpinionIdsInText(citesToSection);
      output.citations.cited_by_this_opinion = citedIds.map(id => ({ opinion_id: id, relationship: 'cited' }));
    }

    // Note: For web parsing, only depth=1 is supported to avoid heavy crawling
    if (citation_depth > 1) {
      output.note = 'Only citation depth 1 supported in web mode.';
    }

    return { content: [{ type: 'text', text: JSON.stringify(output, null, 2) }] };
  }

  // ===== Dockets =====
  async searchDocketsWeb(args) {
    if (!args || typeof args !== 'object') args = {};
    const { case_name, party_name, docket_number, court, date_filed_after, date_filed_before, limit = 5 } = args;
    const validated = validateLimit(limit, 20);

    let q = 'site:courtlistener.com/docket ';
    if (case_name) q += `"${case_name}" `;
    if (party_name) q += `"${party_name}" `;
    if (docket_number) q += `"${docket_number}" `;
    if (court) q += `"${court}" `;

    const results = await this.executeExaSearch(q.trim(), validated, true);
    const filtered = results.filter(r => (r.url || '').includes('/docket/'));
    const mapped = filtered.map(r => {
      const url = r.url || '';
      const text = r.text || '';
      const id = this.extractIdFromUrl(url, 'docket');
      return {
        id,
        docket_number: this.extractFirst(/Docket\s*Number\s*:?\s*([^\n]+)/i, text) || docket_number || null,
        case_name: this.cleanCaseTitle(r.title || '') || null,
        court: this.extractFirst(/Court\s*:?\s*([^\n]+)/i, text) || court || null,
        date_filed: this.extractFirst(/Filed\s*:?\s*([A-Za-z]+\s+\d{1,2},\s*\d{4}|\d{4}-\d{2}-\d{2})/i, text) || null,
        absolute_url: url
      };
    }).filter(d => this.filterByDateWindow(d.date_filed, date_filed_after, date_filed_before));

    return { content: [{ type: 'text', text: JSON.stringify({ count: mapped.length, dockets: mapped }, null, 2) }] };
  }

  // ===== Audio =====
  async searchAudioWeb(args) {
    if (!args || typeof args !== 'object') args = {};
    const { query, judge_name, court, date_argued_after, date_argued_before, min_duration, has_transcript, limit = 5 } = args;
    const validated = validateLimit(limit, 20);

    let q = 'site:courtlistener.com/audio ';
    if (query) q += `${query} `;
    if (judge_name) q += `"${judge_name}" `;
    if (court) q += `"${court}" `;
    if (has_transcript) q += 'transcript ';

    const results = await this.executeExaSearch(q.trim(), validated, true);
    const filtered = results.filter(r => (r.url || '').includes('/audio/'));
    const mapped = filtered
      .map(r => this.mapAudioFromText(r, min_duration))
      .filter(a => a && this.filterByDateWindow(a.date_argued, date_argued_after, date_argued_before));

    return { content: [{ type: 'text', text: JSON.stringify({ count: mapped.length, audio_files: mapped }, null, 2) }] };
  }

  async getAudioDetailsWeb(args) {
    if (!args || typeof args !== 'object') args = {};
    const { audio_id } = args;
    if (!Number.isInteger(audio_id) || audio_id < 1) throw new Error('Invalid audio_id. Must be a positive integer.');

    const q = `site:courtlistener.com/audio/${audio_id}/`;
    const results = await this.executeExaSearch(q, 1, true);
    if (!results.length) return { content: [{ type: 'text', text: JSON.stringify({ error: 'Audio page not found', audio_id }, null, 2) }] };
    const audio = this.mapAudioFromText(results[0]);
    return { content: [{ type: 'text', text: JSON.stringify(audio, null, 2) }] };
  }

  // ===== Judges =====
  async searchJudgesWeb(args) {
    if (!args || typeof args !== 'object') args = {};
    const { name, court, appointer, selection_method, political_affiliation, limit = 5 } = args;
    const validated = validateLimit(limit, 20);
    let q = 'site:courtlistener.com/person ';
    if (name) q += `"${name}" `;
    if (court) q += `"${court}" `;
    if (appointer) q += `"${appointer}" `;
    if (selection_method) q += `"${selection_method}" `;
    if (political_affiliation) q += `"${political_affiliation}" `;

    const results = await this.executeExaSearch(q.trim(), validated, true);
    const filtered = results.filter(r => (r.url || '').includes('/person/'));
    const mapped = filtered.map(r => {
      const url = r.url || '';
      const text = r.text || '';
      const id = this.extractIdFromUrl(url, 'person');
      const fullName = this.cleanCaseTitle(r.title || '') || this.extractFirst(/Name\s*:?\s*([^\n]+)/i, text) || null;
      return {
        id,
        name: fullName,
        name_full: fullName,
        positions_count: (text.match(/Position/gi) || []).length,
        absolute_url: url
      };
    });
    return { content: [{ type: 'text', text: JSON.stringify({ count: mapped.length, judges: mapped }, null, 2) }] };
  }

  async getJudgeDetailsWeb(args) {
    if (!args || typeof args !== 'object') args = {};
    const { judge_id } = args;
    if (!Number.isInteger(judge_id) || judge_id < 1) throw new Error('Invalid judge_id. Must be a positive integer.');
    const q = `site:courtlistener.com/person/${judge_id}/`;
    const results = await this.executeExaSearch(q, 1, true);
    if (!results.length) return { content: [{ type: 'text', text: JSON.stringify({ error: 'Judge page not found', judge_id }, null, 2) }] };
    const r = results[0];
    const text = r.text || '';
    const nameFull = this.cleanCaseTitle(r.title || '') || this.extractFirst(/Name\s*:?\s*([^\n]+)/i, text) || null;
    const details = {
      id: judge_id,
      name: nameFull,
      name_full: nameFull,
      date_birth: this.extractFirst(/Born\s*:?\s*([^\n]+)/i, text) || null,
      date_death: this.extractFirst(/Died\s*:?\s*([^\n]+)/i, text) || null,
      absolute_url: r.url || null
    };
    return { content: [{ type: 'text', text: JSON.stringify(details, null, 2) }] };
  }

  // ===== Courts =====
  async getCourtInfoWeb(args) {
    if (!args || typeof args !== 'object') args = {};
    const { court_id } = args;
    if (!court_id) throw new Error('court_id is required');
    // Try to find a specific court page
    const q = `site:courtlistener.com/court ${court_id}`;
    const results = await this.executeExaSearch(q, 3, true);
    const r = results.find(x => (x.url || '').includes('/court/')) || results[0];
    if (!r) return { content: [{ type: 'text', text: JSON.stringify({ error: 'Court page not found', court_id }, null, 2) }] };
    const text = r.text || '';
    const info = {
      id: court_id,
      short_name: this.extractFirst(/Short\s*Name\s*:?\s*([^\n]+)/i, text) || null,
      full_name: this.extractFirst(/Full\s*Name\s*:?\s*([^\n]+)/i, text) || (r.title || null),
      jurisdiction: this.extractFirst(/Jurisdiction\s*:?\s*([^\n]+)/i, text) || null,
      absolute_url: r.url || null
    };
    return { content: [{ type: 'text', text: JSON.stringify(info, null, 2) }] };
  }

  async listCourtsWeb(args) {
    if (!args || typeof args !== 'object') args = {};
    const { jurisdiction, limit = 5 } = args;
    const validated = validateLimit(limit, 50);
    let q = 'site:courtlistener.com/court ';
    if (jurisdiction) q += `"${jurisdiction}" `;
    const results = await this.executeExaSearch(q.trim(), validated, true);
    const filtered = results.filter(r => (r.url || '').includes('/court/'));
    const courts = filtered.map(r => ({
      id: (r.url || '').match(/\/court\/([^\/]+)\//)?.[1] || null,
      short_name: null,
      full_name: r.title || null,
      jurisdiction: null,
      absolute_url: r.url || null
    }));
    return { content: [{ type: 'text', text: JSON.stringify({ count: courts.length, courts }, null, 2) }] };
  }

  // ===== Case details (best-effort via opinion page) =====
  async getCaseDetailsWeb(args) {
    if (!args || typeof args !== 'object') args = {};
    const { case_id } = args;
    if (!Number.isInteger(case_id) || case_id < 1) throw new Error('Invalid case_id. Must be a positive integer.');
    // Use opinion page as a proxy
    const q = `site:courtlistener.com/opinion/${case_id}/`;
    const results = await this.executeExaSearch(q, 1, true);
    if (!results.length) return { content: [{ type: 'text', text: JSON.stringify({ error: 'Case page not found', case_id }, null, 2) }] };
    const r = results[0];
    const text = r.text || '';
    const details = {
      id: case_id,
      case_name: this.cleanCaseTitle(r.title || '') || null,
      court: this.extractCourt(text),
      date_filed: this.extractFirst(/Filed\s*:?\s*([A-Za-z]+\s+\d{1,2},\s*\d{4}|\d{4}-\d{2}-\d{2})/i, text) || null,
      absolute_url: r.url || null
    };
    return { content: [{ type: 'text', text: JSON.stringify(details, null, 2) }] };
  }

  // ============ helpers ============

  async executeExaSearch(query, limit, includeText, includeFullText = false) {
    if (!this.exaApiKey) {
      throw new Error('Exa API key not configured. Set EXA_API_KEY environment variable.');
    }

    if (this.rateLimiter && typeof this.rateLimiter.enforce === 'function') {
      await this.rateLimiter.enforce();
    }

    const response = await fetch('https://api.exa.ai/search', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'x-api-key': this.exaApiKey
      },
      body: JSON.stringify({
        query,
        numResults: limit,
        includeDomains: ['courtlistener.com', 'www.courtlistener.com'],
        contents: (includeText || includeFullText) ? { text: true } : undefined
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Exa API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    return data.results || [];
  }

  extractSection(text, headerRegex) {
    if (!text) return '';
    const idx = text.search(headerRegex);
    if (idx === -1) return '';
    const after = text.slice(idx);
    // Stop at the next major header or end
    const stopIdx = after.search(/\n\s*(Cited\s*by|Cites\s*to|Citations?|References|Also\s+known\s+as)\b/i);
    if (stopIdx > 0) {
      // The first match is the current header; find the second match to bound the section
      const rest = after.slice(headerRegex.source.length);
      const second = rest.search(/\n\s*(Cited\s*by|Cites\s*to|Citations?|References|Also\s+known\s+as)\b/i);
      if (second > 0) {
        return after.slice(0, second + (headerRegex.source.length || 0));
      }
    }
    return after;
  }

  findOpinionIdsInText(sectionText) {
    if (!sectionText) return [];
    const matches = sectionText.match(/\/opinion\/(\d+)\//g) || [];
    const ids = matches.map(m => {
      const n = m.match(/\/(\d+)\//);
      return n ? Number(n[1]) : null;
    }).filter(Boolean);
    // Deduplicate
    return Array.from(new Set(ids));
  }

  extractIdFromUrl(url, segment) {
    const m = url.match(new RegExp(`/${segment}/(\\d+)/`));
    return m ? Number(m[1]) : null;
  }

  extractFirst(re, text, groupIndex = 1) {
    if (!text) return null;
    const m = text.match(re);
    return m ? (m[groupIndex] || '').trim() : null;
  }

  mapAudioFromText(result, minDuration) {
    const url = result.url || '';
    const text = result.text || '';
    const id = this.extractIdFromUrl(url, 'audio');
    const caseName = this.cleanCaseTitle(result.title || '') || this.extractFirst(/Case\s*Name\s*:?\s*([^\n]+)/i, text) || null;
    const court = this.extractFirst(/Court\s*:?\s*([^\n]+)/i, text) || null;
    const dateArgued = this.extractFirst(/(Date\s*Argued|Argued)\s*:?\s*([A-Za-z]+\s+\d{1,2},\s*\d{4}|\d{4}-\d{2}-\d{2})/i, text, 2) || null;
    const durationStr = this.extractFirst(/Duration\s*:?\s*([0-9:]+|\d+\s*(minutes|min|seconds|sec))/i, text) || null;
    const durationSeconds = this.parseDurationToSeconds(durationStr);
    if (minDuration && durationSeconds && durationSeconds < minDuration * 60) return null;
    const hasTranscript = /Transcript/i.test(text);
    return {
      id,
      case_name: caseName,
      court,
      date_argued: dateArgued,
      duration_seconds: durationSeconds || null,
      duration_minutes: durationSeconds ? Math.round(durationSeconds / 60) : null,
      has_transcript: hasTranscript,
      absolute_url: url
    };
  }

  parseDurationToSeconds(s) {
    if (!s) return null;
    const hms = s.match(/^(\d+):(\d{2})(?::(\d{2}))?$/);
    if (hms) {
      const h = parseInt(hms[1] || '0', 10);
      const m = parseInt(hms[2] || '0', 10);
      const sec = parseInt(hms[3] || '0', 10);
      return h * 3600 + m * 60 + sec;
    }
    const min = s.match(/(\d+)\s*(minutes|min)/i);
    if (min) return parseInt(min[1], 10) * 60;
    const sec = s.match(/(\d+)\s*(seconds|sec)/i);
    if (sec) return parseInt(sec[1], 10);
    return null;
  }

  filterByDateWindow(publishedDate, start, end) {
    if (!start && !end) return true;
    if (!publishedDate) return true; // keep when date unknown
    try {
      const d = new Date(publishedDate);
      if (start && d < new Date(start)) return false;
      if (end && d > new Date(end)) return false;
      return true;
    } catch {
      return true;
    }
  }

  mapOpinionResult(result, includeText, includeFullText = false) {
    const url = result.url || '';
    const title = result.title || '';
    const text = (includeText || includeFullText) ? (result.text || '') : '';

    const opinionId = this.extractOpinionId(url);
    const citations = this.extractCitations(`${title} ${text}`);
    const decidedDate = this.extractDecidedDate(`${title} ${text}`);
    const court = this.extractCourt(`${title} ${text}`);

    const mappedResult = {
      opinion_id: opinionId,
      case_name: this.cleanCaseTitle(title),
      citations,
      court,
      decided_date: decidedDate,
      absolute_url: url,
      published_date: result.publishedDate,
      score: result.score
    };

    // Add snippet if text is requested
    if ((includeText || includeFullText) && text) {
      mappedResult.snippet = text.substring(0, 500);
    }

    // Add full text if requested
    if (includeFullText && text) {
      mappedResult.full_text = text;
    }

    return mappedResult;
  }

  extractOpinionId(url) {
    const m = url.match(/courtlistener\.com\/opinion\/(\d+)\//);
    return m ? Number(m[1]) : null;
  }

  cleanCaseTitle(title) {
    if (!title) return null;
    // Remove trailing "- CourtListener" if present
    return title.replace(/\s*-\s*CourtListener\s*$/i, '').trim();
  }

  extractCitations(text) {
    if (!text) return [];
    const patterns = [
      /\b\d+\s+U\.?S\.?\s+\d+\b/g,          // e.g., 410 U.S. 113
      /\b\d+\s+S\.?Ct\.?\s+\d+\b/g,         // e.g., 93 S.Ct. 705
      /\b\d+\s+L\.?Ed\.?\s?\d*d?\.?\s+\d+\b/g, // e.g., 35 L.Ed.2d 147
      /\b\d+\s+F\.?\s?\d*d\.?\s+\d+\b/g,   // e.g., 123 F.3d 456
      /\b\d+\s+F\.?\s?Supp\.?\s?\d*d?\.?\s+\d+\b/g // e.g., 456 F.Supp. 789
    ];
    const all = new Set();
    for (const re of patterns) {
      const matches = text.match(re) || [];
      matches.forEach(m => all.add(m));
    }
    return Array.from(all);
  }

  extractDecidedDate(text) {
    if (!text) return null;
    const m = text.match(/Decided\s*:\s*([A-Za-z]+\s+\d{1,2},\s*\d{4})/i) ||
              text.match(/Filed\s*:\s*([A-Za-z]+\s+\d{1,2},\s*\d{4})/i);
    return m ? m[1] : null;
  }

  extractCourt(text) {
    if (!text) return null;
    const candidates = [
      /Supreme\s+Court\s+of\s+the\s+United\s+States/i,
      /United\s+States\s+Court\s+of\s+Appeals\s+for\s+the\s+[^\n]+/i,
      /United\s+States\s+District\s+Court\s+for\s+the\s+[^\n]+/i,
      /Court\s+of\s+Appeals\s+of\s+[^\n]+/i
    ];
    for (const re of candidates) {
      const m = text.match(re);
      if (m) return m[0];
    }
    return null;
  }
}


